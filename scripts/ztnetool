#!/usr/bin/env bash
set -euo pipefail

TOKEN_FILE="/run/secrets/ztnet_token"
CORE_FILE="/etc/coredns/Corefile"
GROUP_NAME="coredns"
API_URL="${API_URL:-http://127.0.0.1:3000}"
NETWORK_ID="${NETWORK_ID:-}"
ACTION=""
TOKEN_INPUT=""
TARGET_ID=""

if [[ -t 1 ]]; then
  C_RESET='\033[0m'; C_RED='\033[31m'; C_GREEN='\033[32m'; C_YELLOW='\033[33m'; C_BLUE='\033[34m'; C_CYAN='\033[36m'; C_BOLD='\033[1m'
else
  C_RESET=''; C_RED=''; C_GREEN=''; C_YELLOW=''; C_BLUE=''; C_CYAN=''; C_BOLD=''
fi

info() { printf "%b[i]%b %s\n" "$C_BLUE" "$C_RESET" "$*"; }
ok() { printf "%b[âœ“]%b %s\n" "$C_GREEN" "$C_RESET" "$*"; }
warn() { printf "%b[!]%b %s\n" "$C_YELLOW" "$C_RESET" "$*" >&2; }
err() { printf "%b[x]%b %s\n" "$C_RED" "$C_RESET" "$*" >&2; }
die() { err "$*"; exit 1; }

usage() {
  cat <<USAGE
${C_BOLD}ztnetool${C_RESET} [option]

${C_BOLD}Options:${C_RESET}
  -t "<token>"      Install token into ${TOKEN_FILE}
                    If omitted, interactive secure input is used
  -c                Validate installed token and API availability
  -l                Get available controllers/networks
  -n <id>           Get network and connected-client information
                    (<network_id> or <node_id>)

${C_BOLD}Additional:${C_RESET}
  --api-url URL      API URL (default: ${API_URL})
  --network-id ID    Network ID for checks/node lookup
  --token-file PATH  Token path (default: ${TOKEN_FILE})
  --corefile PATH    CoreDNS Corefile path (default: ${CORE_FILE})
  -h, --help         Show help
USAGE
}

ensure_group_and_user() {
  if ! getent group "$GROUP_NAME" >/dev/null; then
    info "Creating system group ${GROUP_NAME}"
    groupadd --system "$GROUP_NAME"
  fi
  if ! getent passwd "$GROUP_NAME" >/dev/null; then
    info "Creating system user ${GROUP_NAME}"
    local shell_path="/usr/sbin/nologin"
    [[ -x "$shell_path" ]] || shell_path="/bin/false"
    useradd --system --gid "$GROUP_NAME" --home-dir /nonexistent --shell "$shell_path" "$GROUP_NAME"
  fi
}

extract_network_id_from_corefile() {
  [[ -f "$CORE_FILE" ]] || return 1
  awk '/^[[:space:]]*network_id[[:space:]]+/ {print $2; exit}' "$CORE_FILE"
}

read_token_from_file() {
  [[ -f "$TOKEN_FILE" ]] || return 1
  tr -d '\r' < "$TOKEN_FILE" | head -n1
}

require_token() {
  local token
  token="$(read_token_from_file || true)"
  [[ -n "$token" ]] || die "Token not found in ${TOKEN_FILE}"
  printf '%s' "$token"
}

prompt_token() {
  local token="${1:-}"
  if [[ -z "$token" ]]; then
    printf "%b" "${C_CYAN}Enter ZTNET API token:${C_RESET} " >&2
    read -r -s token
    printf '\n' >&2
  fi
  [[ -n "$token" ]] || die "Empty token is not allowed"
  printf '%s' "$token"
}

write_token() {
  local token="$1"
  local token_dir tmp

  token_dir="$(dirname "$TOKEN_FILE")"
  install -d -m 0750 "$token_dir"

  tmp="$(mktemp "${TOKEN_FILE}.tmp.XXXXXX")"
  trap 'rm -f "$tmp"' EXIT
  printf '%s\n' "$token" > "$tmp"
  chown root:"$GROUP_NAME" "$tmp"
  chmod 0440 "$tmp"
  mv -f "$tmp" "$TOKEN_FILE"
  trap - EXIT

  ok "Token saved: ${TOKEN_FILE} (root:${GROUP_NAME}, 0440)"
}

api_get() {
  local path="$1"
  local token="$2"
  curl -fsS --connect-timeout 5 --max-time 20 -H "x-ztnet-auth: ${token}" "${API_URL%/}${path}"
}

check_token_and_api() {
  local token="$1"
  local network_id="$2"
  [[ -n "$network_id" ]] || die "NETWORK_ID is required (--network-id / env / Corefile)"

  local status
  status="$(curl -sS -o /dev/null -w '%{http_code}' --connect-timeout 5 --max-time 20 -H "x-ztnet-auth: ${token}" "${API_URL%/}/api/v1/network/${network_id}" || true)"

  case "$status" in
    200) ok "Token is valid, API reachable, network ${network_id} exists" ;;
    401|403) die "Token is invalid (HTTP ${status})" ;;
    404) die "Network ${network_id} not found (HTTP 404)" ;;
    000) die "Cannot reach API (${API_URL})" ;;
    *) die "Unexpected API response: HTTP ${status}" ;;
  esac
}

list_controllers() {
  local token="$1"
  info "Fetching network list..."

  if api_get "/api/v1/network" "$token" 2>/dev/null; then
    printf '\n'
    ok "Network list received"
    return 0
  fi

  warn "Endpoint /api/v1/network unavailable, trying /api/v1/controller/network"
  api_get "/api/v1/controller/network" "$token"
  printf '\n'
  ok "Controller/network list received"
}

show_network_or_node() {
  local token="$1"
  local id="$2"
  [[ -n "$id" ]] || die "For -n provide network_id or node_id"

  if [[ "$id" =~ ^[0-9a-fA-F]{16}$ ]]; then
    info "Fetching data for network ${id}"
    printf "%b\n" "${C_BOLD}--- Network ---${C_RESET}"
    api_get "/api/v1/network/${id}" "$token"
    printf "\n%b\n" "${C_BOLD}--- Members ---${C_RESET}"
    api_get "/api/v1/network/${id}/member" "$token"
    return 0
  fi

  local network_id="${NETWORK_ID:-$(extract_network_id_from_corefile || true)}"
  [[ -n "$network_id" ]] || die "For node_id lookup, NETWORK_ID is required (env NETWORK_ID or Corefile)"
  info "Searching node_id=${id} in network ${network_id}"
  api_get "/api/v1/network/${network_id}/member" "$token" | awk -v needle="$id" '
    BEGIN { found=0 }
    { print }
    index(tolower($0), tolower(needle)) > 0 { found=1 }
    END { if (found==0) exit 10 }
  ' || die "node_id ${id} not found or API unavailable"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -t)
      ACTION="set-token"
      if [[ $# -ge 2 && ! "$2" =~ ^- ]]; then
        TOKEN_INPUT="$2"
        shift
      fi
      ;;
    -c) ACTION="check" ;;
    -l) ACTION="list" ;;
    -n)
      ACTION="network"
      [[ $# -ge 2 ]] || die "-n requires an argument"
      TARGET_ID="$2"
      shift
      ;;
    --api-url)
      [[ $# -ge 2 ]] || die "--api-url requires an argument"
      API_URL="$2"
      shift
      ;;
    --network-id)
      [[ $# -ge 2 ]] || die "--network-id requires an argument"
      NETWORK_ID="$2"
      shift
      ;;
    --token-file)
      [[ $# -ge 2 ]] || die "--token-file requires an argument"
      TOKEN_FILE="$2"
      shift
      ;;
    --corefile)
      [[ $# -ge 2 ]] || die "--corefile requires an argument"
      CORE_FILE="$2"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *) die "Unknown argument: $1" ;;
  esac
  shift
done

[[ -n "$ACTION" ]] || { usage; exit 1; }

if [[ -z "$NETWORK_ID" ]]; then
  NETWORK_ID="$(extract_network_id_from_corefile || true)"
fi

case "$ACTION" in
  set-token)
    [[ "$EUID" -eq 0 ]] || die "Run with root/sudo"
    ensure_group_and_user
    write_token "$(prompt_token "$TOKEN_INPUT")"
    ;;
  check)
    check_token_and_api "$(require_token)" "$NETWORK_ID"
    ;;
  list)
    list_controllers "$(require_token)"
    ;;
  network)
    show_network_or_node "$(require_token)" "$TARGET_ID"
    ;;
esac
